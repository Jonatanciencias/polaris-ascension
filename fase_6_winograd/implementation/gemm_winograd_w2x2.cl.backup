// FASE 6: Winograd Convolution Adaptation para GEMM
// Kernel OpenCL básico W(2×2, 3×3)
// Fecha: Enero 2026

// Transform matrices constantes (pre-computadas)
#define WINOGRAD_TILE_SIZE 4
#define OUTPUT_TILE_SIZE 2
#define KERNEL_SIZE 3

// Transform matrices as 1D arrays to avoid initialization issues
__constant float G_1D[16] = {
    1.0f, 0.0f, -1.0f, 0.0f,
    0.0f, 1.0f, 1.0f, 0.0f,
    0.0f, -1.0f, 1.0f, 0.0f,
    0.0f, 1.0f, 0.0f, -1.0f
};

__constant float BT_1D[12] = {
    1.0f, 0.0f, 0.0f,
    0.5f, 0.5f, 0.5f,
    0.5f, -0.5f, 0.5f,
    0.0f, 0.0f, 1.0f
};

__constant float AT_1D[8] = {
    1.0f, 1.0f, 1.0f, 0.0f,
    0.0f, 1.0f, -1.0f, -1.0f
};

__constant float AT_T_1D[8] = {
    1.0f, 0.0f,
    1.0f, 1.0f,
    1.0f, -1.0f,
    0.0f, -1.0f
};

// Input transform: U = G * A * G^T
void winograd_input_transform(const float input_tile[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE],
                              float U[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE]) {

    // Paso 1: A * G^T (temporal) - G^T[k][j] = G[j][k] = G_1D[j*4 + k]
    float temp[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE];
    for (int i = 0; i < WINOGRAD_TILE_SIZE; i++) {
        for (int j = 0; j < WINOGRAD_TILE_SIZE; j++) {
            temp[i][j] = 0.0f;
            for (int k = 0; k < WINOGRAD_TILE_SIZE; k++) {
                temp[i][j] += input_tile[i][k] * G_1D[j*WINOGRAD_TILE_SIZE + k];  // G^T[k][j] = G[j][k]
            }
        }
    }

    // Paso 2: G * temp
    for (int i = 0; i < WINOGRAD_TILE_SIZE; i++) {
        for (int j = 0; j < WINOGRAD_TILE_SIZE; j++) {
            U[i][j] = 0.0f;
            for (int k = 0; k < WINOGRAD_TILE_SIZE; k++) {
                U[i][j] += G_1D[i*WINOGRAD_TILE_SIZE + k] * temp[k][j];
            }
        }
    }
}

// Kernel transform: V = B^T * B (correct Winograd implementation) - REMOVED for simplified debugging

// Output transform: C = A^T * M * A^T^T
void winograd_output_transform(const float M[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE],
                               float output_tile[OUTPUT_TILE_SIZE][OUTPUT_TILE_SIZE]) {

    // Paso 1: M * A^T^T (temporal) - AT_T is accessed as 1D array
    float temp[WINOGRAD_TILE_SIZE][OUTPUT_TILE_SIZE];
    for (int i = 0; i < WINOGRAD_TILE_SIZE; i++) {
        for (int j = 0; j < OUTPUT_TILE_SIZE; j++) {
            temp[i][j] = 0.0f;
            for (int k = 0; k < WINOGRAD_TILE_SIZE; k++) {
                temp[i][j] += M[i][k] * AT_T_1D[k*OUTPUT_TILE_SIZE + j];
            }
        }
    }

    // Paso 2: A^T * temp - AT is accessed as 1D array
    for (int i = 0; i < OUTPUT_TILE_SIZE; i++) {
        for (int j = 0; j < OUTPUT_TILE_SIZE; j++) {
            output_tile[i][j] = 0.0f;
            for (int k = 0; k < WINOGRAD_TILE_SIZE; k++) {
                output_tile[i][j] += AT_1D[i*WINOGRAD_TILE_SIZE + k] * temp[k][j];
            }
        }
    }
}

// Kernel principal Winograd GEMM
__kernel void gemm_winograd_w2x2_basic(
    __global const float* restrict A,  // Input matrix A (M x K)
    __global const float* restrict B,  // Input matrix B (K x N)
    __global float* restrict C,        // Output matrix C (M x N)
    const int M, const int N, const int K
) {
    // Winograd GEMM implementation
    const int gx = get_global_id(0);     // Output column
    const int gy = get_global_id(1);     // Output row

    // For POC: process one 2x2 output tile
    if (gx == 0 && gy == 0) {
        // Load input tile 4x4 (simplified - smaller values for debugging)
        float input_tile[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE] = {
            {1.0f, 0.0f, 0.0f, 0.0f},
            {0.0f, 1.0f, 0.0f, 0.0f},
            {0.0f, 0.0f, 1.0f, 0.0f},
            {0.0f, 0.0f, 0.0f, 1.0f}
        };

        // Load kernel 3x3 (simplified - should come from B matrix)
        float kernel_tile[KERNEL_SIZE][KERNEL_SIZE] = {
            {1.0f, 0.0f, 0.0f},
            {0.0f, 1.0f, 0.0f},
            {0.0f, 0.0f, 1.0f}
        };

        // Input transform
        float U[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE];
        winograd_input_transform(input_tile, U);

        // Kernel transform - SIMPLIFIED for debugging
        float V[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE];
        // Just copy kernel to V for now
        for (int i = 0; i < KERNEL_SIZE; i++) {
            for (int j = 0; j < KERNEL_SIZE; j++) {
                V[i][j] = kernel_tile[i][j];
            }
        }
        // Fill rest with zeros
        for (int i = 0; i < WINOGRAD_TILE_SIZE; i++) {
            for (int j = KERNEL_SIZE; j < WINOGRAD_TILE_SIZE; j++) {
                V[i][j] = 0.0f;
            }
        }

        // Element-wise multiplication
        float M[WINOGRAD_TILE_SIZE][WINOGRAD_TILE_SIZE];
        for (int i = 0; i < WINOGRAD_TILE_SIZE; i++) {
            for (int j = 0; j < WINOGRAD_TILE_SIZE; j++) {
                M[i][j] = U[i][j] * V[i][j];
            }
        }

        // Output transform
        float output_tile[OUTPUT_TILE_SIZE][OUTPUT_TILE_SIZE];
        winograd_output_transform(M, output_tile);

        // Write result to global memory
        for (int i = 0; i < OUTPUT_TILE_SIZE; i++) {
            for (int j = 0; j < OUTPUT_TILE_SIZE; j++) {
                C[i * N + j] = output_tile[i][j];
            }
        }
    }
}